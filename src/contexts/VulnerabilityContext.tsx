import React, { createContext, useState, useEffect, useContext, ReactNode } from 'react';
import { Vulnerability, FilterOptions, VulnerabilityStats } from '../interfaces/VulnerabilityData';
import { 
  fetchVulnerabilityData, 
  filterVulnerabilities, 
  generateVulnerabilityStats,
  applyKaiStatusFilters,
  paginateVulnerabilities
} from '../services/VulnerabilityService';

interface VulnerabilityContextType {
  isLoading: boolean;
  error: Error | null;
  allVulnerabilities: Vulnerability[];
  filteredVulnerabilities: Vulnerability[];
  displayedVulnerabilities: Vulnerability[];
  stats: VulnerabilityStats | null;
  filterOptions: FilterOptions;
  setFilterOptions: (options: FilterOptions) => void;
  page: number;
  setPage: (page: number) => void;
  pageSize: number;
  setPageSize: (size: number) => void;
  totalCount: number;
  applyAnalysisFilter: () => void;
  applyAIAnalysisFilter: () => void;
  selectedVulnerability: Vulnerability | null;
  setSelectedVulnerability: (vulnerability: Vulnerability | null) => void;
  resetFilters: () => void;
  setAllVulnerabilities: (data: Vulnerability[]) => void;
  analysisMode: 'none' | 'analysis' | 'aiAnalysis';
  toggleAnalysisMode: (mode: 'none' | 'analysis' | 'aiAnalysis') => void;
}

const defaultFilterOptions: FilterOptions = {
  severity: [],
  kaiStatus: [],
  vendor: [],
  product: [],
  vulnerabilityType: [],
  dateRange: {
    start: null,
    end: null,
  },
  cvssRange: {
    min: 0,
    max: 10,
  },
};

const VulnerabilityContext = createContext<VulnerabilityContextType | undefined>(undefined);

export const VulnerabilityProvider: React.FC<{ children: ReactNode }> = ({ children }) => {
  const [isLoading, setIsLoading] = useState(true);
  const [error, setError] = useState<Error | null>(null);
  const [allVulnerabilities, setAllVulnerabilities] = useState<Vulnerability[]>([]);
  const [filteredVulnerabilities, setFilteredVulnerabilities] = useState<Vulnerability[]>([]);
  const [displayedVulnerabilities, setDisplayedVulnerabilities] = useState<Vulnerability[]>([]);
  const [stats, setStats] = useState<VulnerabilityStats | null>(null);
  const [filterOptions, setFilterOptions] = useState<FilterOptions>(defaultFilterOptions);
  const [page, setPage] = useState(1);
  const [pageSize, setPageSize] = useState(20);
  const [totalCount, setTotalCount] = useState(0);
  const [selectedVulnerability, setSelectedVulnerability] = useState<Vulnerability | null>(null);
  const [analysisMode, setAnalysisMode] = useState<'none' | 'analysis' | 'aiAnalysis'>('none');

  // Load initial data
  useEffect(() => {
    const loadData = async () => {
      try {
        setIsLoading(true);
        const data = await fetchVulnerabilityData();
        setAllVulnerabilities(data);
        setFilteredVulnerabilities(data);
        
        const initialStats = generateVulnerabilityStats(data);
        setStats(initialStats);
        
        setError(null);
      } catch (err) {
        setError(err instanceof Error ? err : new Error('Unknown error occurred'));
      } finally {
        setIsLoading(false);
      }
    };

    loadData();
  }, []);

  // Apply filters when filter options change
  useEffect(() => {
    // Ensure allVulnerabilities is an array before calling filter
    if (Array.isArray(allVulnerabilities) && allVulnerabilities.length > 0) {
      const filtered = filterVulnerabilities(allVulnerabilities, filterOptions);
      setFilteredVulnerabilities(filtered);
      setPage(1); // Reset to first page when filters change
    } else {
      console.warn('allVulnerabilities is not a valid array for filtering');
      setFilteredVulnerabilities([]);
    }
  }, [filterOptions, allVulnerabilities]);

  // Update stats when filtered data changes
  useEffect(() => {
    if (filteredVulnerabilities.length > 0) {
      const newStats = generateVulnerabilityStats(filteredVulnerabilities);
      setStats(newStats);
    }
  }, [filteredVulnerabilities]);

  // Apply pagination
  useEffect(() => {
    const { items, totalCount: count } = paginateVulnerabilities(
      filteredVulnerabilities,
      page,
      pageSize
    );
    setDisplayedVulnerabilities(items);
    setTotalCount(count);
  }, [filteredVulnerabilities, page, pageSize]);

  // Apply "Analysis" filter
  const applyAnalysisFilter = () => {
    const filtered = applyKaiStatusFilters(allVulnerabilities, 'analysis');
    setFilteredVulnerabilities(filtered);
    setAnalysisMode('analysis');
    setPage(1);
  };

  // Apply "AI Analysis" filter
  const applyAIAnalysisFilter = () => {
    const filtered = applyKaiStatusFilters(allVulnerabilities, 'aiAnalysis');
    setFilteredVulnerabilities(filtered);
    setAnalysisMode('aiAnalysis');
    setPage(1);
  };

  // Toggle between analysis modes
  const toggleAnalysisMode = (mode: 'none' | 'analysis' | 'aiAnalysis') => {
    if (mode === analysisMode) {
      // If clicking the same mode again, turn it off
      setAnalysisMode('none');
      setFilteredVulnerabilities(filterVulnerabilities(allVulnerabilities, filterOptions));
    } else {
      // Apply the selected mode
      const filtered = mode === 'none' 
        ? filterVulnerabilities(allVulnerabilities, filterOptions)
        : applyKaiStatusFilters(allVulnerabilities, mode as 'analysis' | 'aiAnalysis');
      setFilteredVulnerabilities(filtered);
      setAnalysisMode(mode);
    }
    setPage(1);
  };

  // Reset filters
  const resetFilters = () => {
    setFilterOptions(defaultFilterOptions);
    setFilteredVulnerabilities(allVulnerabilities);
    setAnalysisMode('none');
    setPage(1);
  };

  // Added: Allow injection of local data from external sources
  const setAllVulnerabilitiesAndSync = (data: Vulnerability[]) => {
    console.log(`Received new dataset containing ${data.length} vulnerability items`);
    
    // Check data validity
    if (!Array.isArray(data)) {
      console.error('Received data is not an array:', data);
      setError(new Error('Invalid data format: expected an array of vulnerabilities'));
      return;
    }
    
    if (data.length === 0) {
      console.warn('Received empty data array');
      setAllVulnerabilities([]);
      setFilteredVulnerabilities([]);
      setStats({
        totalCount: 0,
        severityDistribution: {},
        kaiStatusDistribution: {},
        vendorDistribution: {},
        vulnerabilityTypeDistribution: {},
        timelineData: []
      });
      setPage(1);
      setError(new Error('No vulnerability data found'));
      return;
    }
    
    // Validate that at least the first element has the necessary fields
    const firstItem = data[0];
    console.log('First item data example:', JSON.stringify(firstItem).slice(0, 200) + '...');
    
    if (!firstItem.cveId || typeof firstItem.severity === 'undefined') {
      console.warn('Data does not match the expected Vulnerability interface:', 
        `cveId: ${firstItem.cveId ? 'exists' : 'missing'}, ` + 
        `severity: ${typeof firstItem.severity !== 'undefined' ? 'exists' : 'missing'}`);
    }
    
    try {
      console.log('Updating global state...');
      setIsLoading(true); // Set loading state to ensure UI displays correctly
      
      // Update all states
      setAllVulnerabilities(data);
      setFilteredVulnerabilities(data);
      
      console.log('Generating statistics...');
      const newStats = generateVulnerabilityStats(data);
      console.log('Statistics results:', 
        `Total: ${newStats.totalCount}, ` +
        `Severity distribution: ${Object.keys(newStats.severityDistribution).length} types, ` +
        `Vendors: ${Object.keys(newStats.vendorDistribution).length}`);
      
      setStats(newStats);
      setPage(1);
      setError(null);
      
      console.log('Data update complete, interface should refresh');
    } catch (err) {
      console.error('Error processing data:', err);
      setError(err instanceof Error ? err : new Error('Unknown error occurred while processing data'));
    } finally {
      setIsLoading(false);
    }
  };

  const value = {
    isLoading,
    error,
    allVulnerabilities,
    filteredVulnerabilities,
    displayedVulnerabilities,
    stats,
    filterOptions,
    setFilterOptions,
    page,
    setPage,
    pageSize,
    setPageSize,
    totalCount,
    applyAnalysisFilter,
    applyAIAnalysisFilter,
    selectedVulnerability,
    setSelectedVulnerability,
    resetFilters,
    setAllVulnerabilities: setAllVulnerabilitiesAndSync,
    analysisMode,
    toggleAnalysisMode
  };

  return (
    <VulnerabilityContext.Provider value={value}>
      {children}
    </VulnerabilityContext.Provider>
  );
};

export const useVulnerability = (): VulnerabilityContextType => {
  const context = useContext(VulnerabilityContext);
  if (context === undefined) {
    throw new Error('useVulnerability must be used within a VulnerabilityProvider');
  }
  return context;
}; 