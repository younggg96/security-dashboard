import { Vulnerability, FilterOptions, VulnerabilityStats, JsonVulnerability, UploadedJsonStructure } from '../interfaces/VulnerabilityData';
import { VulnerabilityStore } from '../utils/VulnerabilityDataStructures';

// Data is loaded from user-uploaded files only
// No remote data fetching is supported

// Global singleton storage instance
let dataStore: VulnerabilityStore | null = null;

/**
 * Map JSON data to application's Vulnerability type
 */
const mapJsonToVulnerability = (jsonVulnerability: JsonVulnerability): Vulnerability => {
  return {
    cveId: jsonVulnerability.cve,
    severity: jsonVulnerability.severity,
    kaiStatus: jsonVulnerability.status || 'unknown',
    cvss: jsonVulnerability.cvss || 0,
    summary: jsonVulnerability.description,
    publishedDate: jsonVulnerability.published,
    lastModifiedDate: jsonVulnerability.fixDate || jsonVulnerability.published,
    vulnerable_version: '',  // These fields may not exist in JSON, supplement based on actual data
    patched_version: '',
    vendor: '',
    product: jsonVulnerability.packageName || '',
    exploitabilityScore: 0,
    impactScore: 0,
    vulnerabilityType: jsonVulnerability.type || '',
    cweId: '',
    references: [],
    tags: Object.keys(jsonVulnerability.riskFactors || {})
  };
};

/**
 * Extract vulnerability data from complex uploaded JSON structure
 */
export const extractVulnerabilitiesFromUploadedJson = (data: UploadedJsonStructure): Vulnerability[] => {
  const vulnerabilities: Vulnerability[] = [];

  // Traverse complex nested structure to extract all vulnerabilities
  Object.values(data.groups || {}).forEach(group => {
    Object.values(group.repos || {}).forEach(repo => {
      Object.values(repo.images || {}).forEach(image => {
        if (Array.isArray(image.vulnerabilities)) {
          image.vulnerabilities.forEach(jsonVuln => {
            try {
              const vuln = mapJsonToVulnerability(jsonVuln);
              // Add additional information
              vuln.vendor = data.name || '';
              vuln.product = image.name || jsonVuln.packageName || '';
              vulnerabilities.push(vuln);
            } catch (error) {
              console.error('Error mapping vulnerability:', error, jsonVuln);
            }
          });
        }
      });
    });
  });

  return vulnerabilities;
};

/**
 * Preprocess raw JSON data into Vulnerability type
 */
const preprocessJsonData = (data: any): Vulnerability[] => {
  let vulnerabilities: Vulnerability[] = [];

  if (Array.isArray(data)) {
    // If data is already an array, try to map directly
    vulnerabilities = data.map(item => {
      if (typeof item === 'object' && item.cve) {
        return mapJsonToVulnerability(item as JsonVulnerability);
      } else if (typeof item === 'object' && item.cveId) {
        // If data already conforms to Vulnerability interface, return directly
        return item as Vulnerability;
      }
      // Unrecognized format, return a minimized default object
      return {
        cveId: `unknown-${Math.random().toString(36).substring(2, 15)}`,
        severity: 'unknown',
        kaiStatus: 'unknown',
        cvss: 0,
        summary: JSON.stringify(item),
        publishedDate: new Date().toISOString(),
        lastModifiedDate: new Date().toISOString(),
        vulnerable_version: '',
        patched_version: '',
        vendor: '',
        product: '',
        exploitabilityScore: 0,
        impactScore: 0,
        vulnerabilityType: '',
        cweId: '',
        references: []
      };
    });
  } else if (data && typeof data === 'object') {
    // Try to extract vulnerability data from the object
    if ('groups' in data) {
      // May be an uploaded JSON structure
      vulnerabilities = extractVulnerabilitiesFromUploadedJson(data as UploadedJsonStructure);
    } else {
      // Look for fields that might contain vulnerability arrays
      const commonArrayProps = ['vulnerabilities', 'items', 'data', 'cves', 'results'];
      for (const prop of commonArrayProps) {
        if (data[prop] && Array.isArray(data[prop])) {
          vulnerabilities = data[prop].map((item: any) => {
            if (typeof item === 'object' && item.cve) {
              return mapJsonToVulnerability(item as JsonVulnerability);
            } else if (typeof item === 'object' && item.cveId) {
              return item as Vulnerability;
            }
            return null;
          }).filter((v: any): v is Vulnerability => v !== null);
          break;
        }
      }

      // If still not found, look for any array-type properties
      if (vulnerabilities.length === 0) {
        const arrayProps = Object.entries(data)
          .filter(([_, value]) => Array.isArray(value))
          .map(([key, value]) => ({ key, value: value as any[] }));

        if (arrayProps.length > 0) {
          // Use the first array found
          const firstArray = arrayProps[0].value;
          vulnerabilities = firstArray
            .map((item: any) => {
              if (typeof item === 'object' && item.cve) {
                return mapJsonToVulnerability(item as JsonVulnerability);
              } else if (typeof item === 'object' && item.cveId) {
                return item as Vulnerability;
              }
              return null;
            })
            .filter((v: any): v is Vulnerability => v !== null);
        }
      }
    }
  }

  // Clean and validate data
  return vulnerabilities.filter(v => v && v.cveId);
};

/**
 * Initialize data store
 */
const initializeDataStore = (vulnerabilities: Vulnerability[]): VulnerabilityStore => {
  const store = new VulnerabilityStore();
  store.addBulk(vulnerabilities);
  return store;
};

/**
 * Get all vulnerability data
 * Returns the current cached data
 */
export const getAllVulnerabilities = async (): Promise<Vulnerability[]> => {
  return dataStore?.getAll() || [];
};

/**
 * Query vulnerabilities based on filter criteria
 */
export const queryVulnerabilities = async (
  filters: FilterOptions
): Promise<Vulnerability[]> => {
  if (!dataStore) {
    return [];
  }

  return dataStore.query({
    severity: filters.severity,
    kaiStatus: filters.kaiStatus,
    vendor: filters.vendor,
    product: filters.product,
    vulnerabilityType: filters.vulnerabilityType,
    cvssRange: filters.cvssRange,
    dateRange: filters.dateRange
  });
};

/**
 * Get vulnerabilities by CVE ID
 */
export const getVulnerabilityById = async (cveId: string): Promise<Vulnerability[]> => {
  return dataStore?.getById(cveId) || [];
};

/**
 * Get the first vulnerability matching CVE ID (for backward compatibility)
 */
export const getFirstVulnerabilityById = async (cveId: string): Promise<Vulnerability | undefined> => {
  return dataStore?.getFirstById(cveId);
};

/**
 * Get unique instance ID for a vulnerability
 */
export const getVulnerabilityInstanceId = (vulnerability: Vulnerability): string => {
  if (!dataStore) {
    return `${vulnerability.cveId}_0`;
  }
  return dataStore.getVulnerabilityInstanceId(vulnerability);
};

/**
 * Get unique field values (for filter options)
 */
export const getUniqueFieldValues = async (
  field: 'severity' | 'kaiStatus' | 'vendor' | 'product' | 'vulnerabilityType'
): Promise<string[]> => {
  return dataStore?.getUniqueValues(field) || [];
};

/**
 * Apply KAI status filters
 */
export const applyKaiStatusFilters = async (
  filterType: 'analysis' | 'aiAnalysis'
): Promise<Vulnerability[]> => {
  if (!dataStore) {
    return [];
  }

  const allVulnerabilities = dataStore.getAll();
  
  if (filterType === 'analysis') {
    return allVulnerabilities.filter(v => v.kaiStatus !== 'invalid - norisk');
  } else if (filterType === 'aiAnalysis') {
    return allVulnerabilities.filter(v => v.kaiStatus !== 'ai-invalid-norisk');
  }
  
  return allVulnerabilities;
};

/**
 * Generate vulnerability statistics
 */
export const generateVulnerabilityStats = async (
  vulnerabilities?: Vulnerability[]
): Promise<VulnerabilityStats> => {
  if (!vulnerabilities) {
    vulnerabilities = dataStore?.getAll() || [];
  }

  const stats: VulnerabilityStats = {
    totalCount: vulnerabilities.length,
    severityDistribution: {},
    kaiStatusDistribution: {},
    vendorDistribution: {},
    vulnerabilityTypeDistribution: {},
    timelineData: []
  };

  // Process statistics for each vulnerability
  vulnerabilities.forEach(vulnerability => {
    // Severity distribution
    stats.severityDistribution[vulnerability.severity] = 
      (stats.severityDistribution[vulnerability.severity] || 0) + 1;
    
    // KAI status distribution
    stats.kaiStatusDistribution[vulnerability.kaiStatus] = 
      (stats.kaiStatusDistribution[vulnerability.kaiStatus] || 0) + 1;
    
    // Vendor distribution
    stats.vendorDistribution[vulnerability.vendor] = 
      (stats.vendorDistribution[vulnerability.vendor] || 0) + 1;
    
    // Vulnerability type distribution
    stats.vulnerabilityTypeDistribution[vulnerability.vulnerabilityType] = 
      (stats.vulnerabilityTypeDistribution[vulnerability.vulnerabilityType] || 0) + 1;
  });

  // Process timeline data (by month)
  const timelineMap = new Map<string, number>();
  
  vulnerabilities.forEach(vulnerability => {
    const date = new Date(vulnerability.publishedDate);
    const monthYear = `${date.getFullYear()}-${(date.getMonth() + 1).toString().padStart(2, '0')}`;
    
    timelineMap.set(monthYear, (timelineMap.get(monthYear) || 0) + 1);
  });

  // Sort timeline data by date
  stats.timelineData = Array.from(timelineMap.entries())
    .map(([date, count]) => ({ date, count }))
    .sort((a, b) => a.date.localeCompare(b.date));

  return stats;
};

/**
 * Paginate vulnerability data
 */
export const paginateVulnerabilities = (
  data: Vulnerability[],
  page: number,
  pageSize: number
): { items: Vulnerability[]; totalCount: number } => {
  const startIndex = (page - 1) * pageSize;
  const endIndex = startIndex + pageSize;
  
  return {
    items: data.slice(startIndex, endIndex),
    totalCount: data.length
  };
};

/**
 * Load from local JSON file
 * This is the main entry point for loading data
 */
export const loadFromLocalFile = async (
  file: File,
  onProgress?: (progress: number) => void
): Promise<Vulnerability[]> => {
  try {
    return new Promise((resolve, reject) => {
      const fileReader = new FileReader();

      fileReader.onprogress = (event) => {
        if (event.lengthComputable && onProgress) {
          const progress = event.loaded / event.total;
          onProgress(progress);
        }
      };

      fileReader.onload = (event) => {
        try {
          const result = event.target?.result;
          if (typeof result !== 'string') {
            reject(new Error('Unable to read file as text'));
            return;
          }

          const jsonData = JSON.parse(result);
          const vulnerabilities = preprocessJsonData(jsonData);
          
          // Update data store
          dataStore = initializeDataStore(vulnerabilities);
          
          resolve(vulnerabilities);
        } catch (error) {
          reject(error);
        }
      };

      fileReader.onerror = () => {
        reject(new Error('Error reading file'));
      };

      fileReader.readAsText(file);
    });
  } catch (error) {
    console.error('Error loading from local file:', error);
    throw error;
  }
}; 