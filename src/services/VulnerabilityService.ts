import { Vulnerability, FilterOptions, VulnerabilityStats } from '../interfaces/VulnerabilityData';

// Data is loaded from user-uploaded files only
// No remote data fetching is supported

// Cached data to avoid multiple processing
let cachedData: Vulnerability[] | null = null;


/**
 * Returns cached vulnerability data
 * This function now only returns cached data loaded from file uploads
 * If no data is cached, it returns an empty array
 */
export const fetchVulnerabilityData = async (): Promise<Vulnerability[]> => {
  if (cachedData) {
    return Promise.resolve(cachedData);
  }
  
  // Return empty array when no data is cached
  return Promise.resolve([]);
};

/**
 * Force refresh of vulnerability data
 * In this implementation, it simply returns cached data
 * or an empty array if no data has been loaded
 */
export const fetchVulnerabilityDataForce = async (): Promise<Vulnerability[]> => {
  if (cachedData) {
    return Promise.resolve(cachedData);
  }
  
  // Return empty array when no data is cached
  return Promise.resolve([]);
};

/**
 * Clear the cache data
 */
export const clearCache = (): void => {
  cachedData = null;
  console.log('Vulnerability data cache cleared');
};

/**
 * Filters vulnerabilities based on provided filter options
 */
export const filterVulnerabilities = (
  data: Vulnerability[],
  filters: FilterOptions
): Vulnerability[] => {
  return data.filter(vulnerability => {
    // Filter by severity
    if (filters.severity.length > 0 && !filters.severity.includes(vulnerability.severity)) {
      return false;
    }

    // Filter by kaiStatus
    if (filters.kaiStatus.length > 0 && !filters.kaiStatus.includes(vulnerability.kaiStatus)) {
      return false;
    }

    // Filter by vendor
    if (filters.vendor.length > 0 && !filters.vendor.includes(vulnerability.vendor)) {
      return false;
    }

    // Filter by product
    if (filters.product.length > 0 && !filters.product.includes(vulnerability.product)) {
      return false;
    }

    // Filter by vulnerability type
    if (
      filters.vulnerabilityType.length > 0 &&
      !filters.vulnerabilityType.includes(vulnerability.vulnerabilityType)
    ) {
      return false;
    }

    // Filter by date range
    if (filters.dateRange.start || filters.dateRange.end) {
      const publishDate = new Date(vulnerability.publishedDate);
      
      if (filters.dateRange.start && publishDate < new Date(filters.dateRange.start)) {
        return false;
      }
      
      if (filters.dateRange.end && publishDate > new Date(filters.dateRange.end)) {
        return false;
      }
    }

    // Filter by CVSS score range
    if (
      vulnerability.cvss < filters.cvssRange.min ||
      vulnerability.cvss > filters.cvssRange.max
    ) {
      return false;
    }

    return true;
  });
};

/**
 * Generates statistics from vulnerability data
 */
export const generateVulnerabilityStats = (data: Vulnerability[]): VulnerabilityStats => {
  const stats: VulnerabilityStats = {
    totalCount: data.length,
    severityDistribution: {},
    kaiStatusDistribution: {},
    vendorDistribution: {},
    vulnerabilityTypeDistribution: {},
    timelineData: []
  };

  // Process each vulnerability for stats
  data.forEach(vulnerability => {
    // Severity distribution
    stats.severityDistribution[vulnerability.severity] = 
      (stats.severityDistribution[vulnerability.severity] || 0) + 1;
    
    // KAI status distribution
    stats.kaiStatusDistribution[vulnerability.kaiStatus] = 
      (stats.kaiStatusDistribution[vulnerability.kaiStatus] || 0) + 1;
    
    // Vendor distribution
    stats.vendorDistribution[vulnerability.vendor] = 
      (stats.vendorDistribution[vulnerability.vendor] || 0) + 1;
    
    // Vulnerability type distribution
    stats.vulnerabilityTypeDistribution[vulnerability.vulnerabilityType] = 
      (stats.vulnerabilityTypeDistribution[vulnerability.vulnerabilityType] || 0) + 1;
  });

  // Process timeline data (by month)
  const timelineMap = new Map<string, number>();
  
  data.forEach(vulnerability => {
    const date = new Date(vulnerability.publishedDate);
    const monthYear = `${date.getFullYear()}-${(date.getMonth() + 1).toString().padStart(2, '0')}`;
    
    timelineMap.set(monthYear, (timelineMap.get(monthYear) || 0) + 1);
  });

  // Sort timeline data by date
  stats.timelineData = Array.from(timelineMap.entries())
    .map(([date, count]) => ({ date, count }))
    .sort((a, b) => a.date.localeCompare(b.date));

  return stats;
};

/**
 * Filters out vulnerabilities with specific kaiStatus values
 */
export const applyKaiStatusFilters = (
  data: Vulnerability[],
  filterType: 'analysis' | 'aiAnalysis'
): Vulnerability[] => {
  if (filterType === 'analysis') {
    return data.filter(v => v.kaiStatus !== 'invalid - norisk');
  } else if (filterType === 'aiAnalysis') {
    return data.filter(v => v.kaiStatus !== 'ai-invalid-norisk');
  }
  return data;
};

/**
 * Gets unique values for a specific field in the vulnerability data
 */
export const getUniqueFieldValues = (data: Vulnerability[], field: keyof Vulnerability): string[] => {
  const values = new Set<string>();
  
  data.forEach(item => {
    if (typeof item[field] === 'string') {
      values.add(item[field] as string);
    }
  });
  
  return Array.from(values).sort();
};

/**
 * Paginates vulnerability data
 */
export const paginateVulnerabilities = (
  data: Vulnerability[],
  page: number,
  pageSize: number
): { items: Vulnerability[]; totalCount: number } => {
  const startIndex = (page - 1) * pageSize;
  const endIndex = startIndex + pageSize;
  
  return {
    items: data.slice(startIndex, endIndex),
    totalCount: data.length
  };
};

/**
 * Get unique instance ID for a vulnerability
 */
export const getVulnerabilityInstanceId = (vulnerability: Vulnerability): string => {
  // Create a unique ID based on cveId and other properties
  const hashCode = (str: string): number => {
    let hash = 0;
    for (let i = 0; i < str.length; i++) {
      hash = ((hash << 5) - hash) + str.charCodeAt(i);
      hash |= 0; // Convert to 32bit integer
    }
    return Math.abs(hash);
  };
  
  // Combine properties to create a more unique identifier
  const uniqueStr = `${vulnerability.cveId}_${vulnerability.severity}_${vulnerability.vendor}_${vulnerability.product}`;
  const hash = hashCode(uniqueStr);
  
  return `${vulnerability.cveId}_${hash}`;
};