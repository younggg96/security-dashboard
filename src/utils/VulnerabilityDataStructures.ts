import { Vulnerability } from '../interfaces/VulnerabilityData';

/**
 * VulnerabilityMap - Use Map to provide O(1) complexity for CVE ID lookup
 */
export class VulnerabilityMap {
  private vulnerabilityByCveId: Map<string, Vulnerability[]> = new Map();
  private vulnInstanceIds: Map<Vulnerability, string> = new Map();
  private nextInstanceId: number = 1;
  
  constructor(vulnerabilities: Vulnerability[] = []) {
    this.addBulk(vulnerabilities);
  }
  
  /**
   * Generate instance ID for vulnerability to ensure uniqueness even with identical CVE IDs
   */
  private generateInstanceId(vulnerability: Vulnerability): string {
    const instanceId = `${vulnerability.cveId}_${this.nextInstanceId++}`;
    this.vulnInstanceIds.set(vulnerability, instanceId);
    return instanceId;
  }
  
  /**
   * Get instance ID for vulnerability
   */
  getInstanceId(vulnerability: Vulnerability): string {
    if (!this.vulnInstanceIds.has(vulnerability)) {
      return this.generateInstanceId(vulnerability);
    }
    return this.vulnInstanceIds.get(vulnerability)!;
  }
  
  /**
   * Add a single vulnerability
   */
  add(vulnerability: Vulnerability): void {
    const cveId = vulnerability.cveId;
    // Generate instance ID to ensure uniqueness
    this.generateInstanceId(vulnerability);
    
    if (!this.vulnerabilityByCveId.has(cveId)) {
      this.vulnerabilityByCveId.set(cveId, [vulnerability]);
    } else {
      const vulns = this.vulnerabilityByCveId.get(cveId)!;
      // Check if identical vulnerability already exists (by comparing all fields)
      const exists = vulns.some(v => 
        v.severity === vulnerability.severity &&
        v.cvss === vulnerability.cvss &&
        v.kaiStatus === vulnerability.kaiStatus &&
        v.product === vulnerability.product &&
        v.vendor === vulnerability.vendor &&
        v.publishedDate === vulnerability.publishedDate
      );
      
      if (!exists) {
        vulns.push(vulnerability);
      }
    }
  }
  
  /**
   * Add multiple vulnerabilities in bulk
   */
  addBulk(vulnerabilities: Vulnerability[]): void {
    vulnerabilities.forEach(vulnerability => {
      this.add(vulnerability);
    });
  }
  
  /**
   * Get vulnerabilities by CVE ID
   * Returns all vulnerabilities associated with this CVE ID
   */
  get(cveId: string): Vulnerability[] {
    return this.vulnerabilityByCveId.get(cveId) || [];
  }
  
  /**
   * Get the first vulnerability associated with CVE ID (for backward compatibility)
   */
  getFirst(cveId: string): Vulnerability | undefined {
    const vulns = this.get(cveId);
    return vulns.length > 0 ? vulns[0] : undefined;
  }
  
  /**
   * Check if map contains vulnerabilities with specified CVE ID
   */
  has(cveId: string): boolean {
    return this.vulnerabilityByCveId.has(cveId);
  }
  
  /**
   * Delete all vulnerabilities with specified CVE ID
   */
  delete(cveId: string): boolean {
    const vulns = this.vulnerabilityByCveId.get(cveId) || [];
    // Clear instance ID mappings
    vulns.forEach(v => this.vulnInstanceIds.delete(v));
    return this.vulnerabilityByCveId.delete(cveId);
  }
  
  /**
   * Get all vulnerabilities (flattened)
   */
  getAll(): Vulnerability[] {
    const allVulns: Vulnerability[] = [];
    this.vulnerabilityByCveId.forEach(vulns => {
      allVulns.push(...vulns);
    });
    return allVulns;
  }
  
  /**
   * Get count of unique CVE IDs
   */
  size(): number {
    return this.vulnerabilityByCveId.size;
  }
  
  /**
   * Get total count of vulnerability instances
   */
  instanceCount(): number {
    let count = 0;
    this.vulnerabilityByCveId.forEach(vulns => {
      count += vulns.length;
    });
    return count;
  }
  
  /**
   * Clear all vulnerabilities
   */
  clear(): void {
    this.vulnerabilityByCveId.clear();
    this.vulnInstanceIds.clear();
    this.nextInstanceId = 1;
  }
}

/**
 * VulnerabilityIndex - For multi-dimensional indexing of vulnerability data, providing efficient attribute-based querying
 */
export class VulnerabilityIndex<T = string> {
  private index: Map<T, Set<string>> = new Map();
  
  /**
   * Add CVE ID for specified attribute value
   */
  add(key: T, cveId: string): void {
    let cveIds = this.index.get(key);
    if (!cveIds) {
      cveIds = new Set<string>();
      this.index.set(key, cveIds);
    }
    cveIds.add(cveId);
  }
  
  /**
   * Get CVE ID set for attribute value
   */
  get(key: T): Set<string> {
    return this.index.get(key) || new Set<string>();
  }
  
  /**
   * Get all keys
   */
  getKeys(): T[] {
    return Array.from(this.index.keys());
  }
  
  /**
   * Remove CVE ID from specified key
   */
  remove(key: T, cveId: string): boolean {
    const cveIds = this.index.get(key);
    if (cveIds) {
      const result = cveIds.delete(cveId);
      if (cveIds.size === 0) {
        this.index.delete(key);
      }
      return result;
    }
    return false;
  }
  
  /**
   * Clear index
   */
  clear(): void {
    this.index.clear();
  }
}

/**
 * RangeIndex - For range queries, such as CVSS scores
 */
export class RangeIndex {
  private items: Array<{ value: number; cveIds: Set<string> }> = [];
  private sorted: boolean = true;
  
  /**
   * Add range index item
   */
  add(value: number, cveId: string): void {
    // Check if value already exists
    const existingItem = this.items.find(item => item.value === value);
    if (existingItem) {
      existingItem.cveIds.add(cveId);
    } else {
      this.items.push({ value, cveIds: new Set([cveId]) });
      this.sorted = false;
    }
  }
  
  /**
   * Ensure index is sorted
   */
  private ensureSorted(): void {
    if (!this.sorted) {
      this.items.sort((a, b) => a.value - b.value);
      this.sorted = true;
    }
  }
  
  /**
   * Query CVE IDs within range
   */
  queryRange(min: number, max: number): Set<string> {
    this.ensureSorted();
    
    const result = new Set<string>();
    for (const item of this.items) {
      if (item.value >= min && item.value <= max) {
        item.cveIds.forEach(cveId => result.add(cveId));
      } else if (item.value > max) {
        break;
      }
    }
    
    return result;
  }
  
  /**
   * Clear index
   */
  clear(): void {
    this.items = [];
    this.sorted = true;
  }
}

/**
 * DateIndex - For date range queries
 */
export class DateIndex {
  private items: Array<{ date: Date; cveIds: Set<string> }> = [];
  private sorted: boolean = true;
  
  /**
   * Add date index item
   */
  add(dateStr: string, cveId: string): void {
    const date = new Date(dateStr);
    if (isNaN(date.getTime())) {
      console.warn(`Invalid date format for CVE ${cveId}: ${dateStr}`);
      return;
    }
    
    // Check if date already exists
    const existingItem = this.items.find(
      item => item.date.getTime() === date.getTime()
    );
    
    if (existingItem) {
      existingItem.cveIds.add(cveId);
    } else {
      this.items.push({ date, cveIds: new Set([cveId]) });
      this.sorted = false;
    }
  }
  
  /**
   * Ensure index is sorted
   */
  private ensureSorted(): void {
    if (!this.sorted) {
      this.items.sort((a, b) => a.date.getTime() - b.date.getTime());
      this.sorted = true;
    }
  }
  
  /**
   * Query CVE IDs within date range
   */
  queryRange(startDate: Date | null, endDate: Date | null): Set<string> {
    this.ensureSorted();
    
    const result = new Set<string>();
    for (const item of this.items) {
      const valid = (
        startDate === null || item.date >= startDate
      ) && (
        endDate === null || item.date <= endDate
      );
      
      if (valid) {
        item.cveIds.forEach(cveId => result.add(cveId));
      } else if (endDate !== null && item.date > endDate) {
        break;
      }
    }
    
    return result;
  }
  
  /**
   * Clear index
   */
  clear(): void {
    this.items = [];
    this.sorted = true;
  }
}

/**
 * VulnerabilityStore - Integrated vulnerability data storage with various indices
 */
export class VulnerabilityStore {
  private dataMap: VulnerabilityMap = new VulnerabilityMap();
  private severityIndex: VulnerabilityIndex = new VulnerabilityIndex();
  private kaiStatusIndex: VulnerabilityIndex = new VulnerabilityIndex();
  private vendorIndex: VulnerabilityIndex = new VulnerabilityIndex();
  private productIndex: VulnerabilityIndex = new VulnerabilityIndex();
  private typeIndex: VulnerabilityIndex = new VulnerabilityIndex();
  private cvssIndex: RangeIndex = new RangeIndex();
  private publishDateIndex: DateIndex = new DateIndex();
  
  constructor(vulnerabilities: Vulnerability[] = []) {
    this.addBulk(vulnerabilities);
  }
  
  /**
   * Add a single vulnerability and update all indices
   */
  add(vulnerability: Vulnerability): void {
    // Update main data storage
    this.dataMap.add(vulnerability);
    
    // Update various indices
    const { cveId, severity, kaiStatus, vendor, product, vulnerabilityType, cvss, publishedDate } = vulnerability;
    
    this.severityIndex.add(severity, cveId);
    this.kaiStatusIndex.add(kaiStatus, cveId);
    this.vendorIndex.add(vendor, cveId);
    this.productIndex.add(product, cveId);
    this.typeIndex.add(vulnerabilityType, cveId);
    this.cvssIndex.add(cvss, cveId);
    this.publishDateIndex.add(publishedDate, cveId);
  }
  
  /**
   * Add vulnerabilities in bulk
   */
  addBulk(vulnerabilities: Vulnerability[]): void {
    vulnerabilities.forEach(vulnerability => this.add(vulnerability));
  }
  
  /**
   * Get vulnerabilities by CVE ID
   */
  getById(cveId: string): Vulnerability[] {
    return this.dataMap.get(cveId);
  }
  
  /**
   * Get first vulnerability matching CVE ID (for backward compatibility)
   */
  getFirstById(cveId: string): Vulnerability | undefined {
    return this.dataMap.getFirst(cveId);
  }
  
  /**
   * Get all vulnerabilities
   */
  getAll(): Vulnerability[] {
    return this.dataMap.getAll();
  }
  
  /**
   * Get unique instance ID for a vulnerability
   */
  getVulnerabilityInstanceId(vulnerability: Vulnerability): string {
    return this.dataMap.getInstanceId(vulnerability);
  }
  
  /**
   * Query vulnerabilities based on filter criteria
   */
  query(filters: {
    severity?: string[],
    kaiStatus?: string[],
    vendor?: string[],
    product?: string[],
    vulnerabilityType?: string[],
    cvssRange?: { min: number, max: number },
    dateRange?: { start: string | null, end: string | null }
  }): Vulnerability[] {
    // Process each filter condition, collecting sets of CVE IDs that match
    let candidateSets: Set<string>[] = [];
    
    // Process attribute-based filters
    if (filters.severity && filters.severity.length > 0) {
      const severityCveIds = new Set<string>();
      filters.severity.forEach(severity => {
        this.severityIndex.get(severity).forEach(id => severityCveIds.add(id));
      });
      candidateSets.push(severityCveIds);
    }
    
    if (filters.kaiStatus && filters.kaiStatus.length > 0) {
      const statusCveIds = new Set<string>();
      filters.kaiStatus.forEach(status => {
        this.kaiStatusIndex.get(status).forEach(id => statusCveIds.add(id));
      });
      candidateSets.push(statusCveIds);
    }
    
    if (filters.vendor && filters.vendor.length > 0) {
      const vendorCveIds = new Set<string>();
      filters.vendor.forEach(vendor => {
        this.vendorIndex.get(vendor).forEach(id => vendorCveIds.add(id));
      });
      candidateSets.push(vendorCveIds);
    }
    
    if (filters.product && filters.product.length > 0) {
      const productCveIds = new Set<string>();
      filters.product.forEach(product => {
        this.productIndex.get(product).forEach(id => productCveIds.add(id));
      });
      candidateSets.push(productCveIds);
    }
    
    if (filters.vulnerabilityType && filters.vulnerabilityType.length > 0) {
      const typeCveIds = new Set<string>();
      filters.vulnerabilityType.forEach(type => {
        this.typeIndex.get(type).forEach(id => typeCveIds.add(id));
      });
      candidateSets.push(typeCveIds);
    }
    
    // Process CVSS range filter
    if (filters.cvssRange) {
      const { min, max } = filters.cvssRange;
      candidateSets.push(this.cvssIndex.queryRange(min, max));
    }
    
    // Process date range filter
    if (filters.dateRange) {
      const { start, end } = filters.dateRange;
      const startDate = start ? new Date(start) : null;
      const endDate = end ? new Date(end) : null;
      
      if (startDate || endDate) {
        candidateSets.push(this.publishDateIndex.queryRange(startDate, endDate));
      }
    }
    
    // If no filter conditions, return all vulnerabilities
    if (candidateSets.length === 0) {
      return this.getAll();
    }
    
    // Find intersection
    let resultCveIds: Set<string> = candidateSets[0];
    for (let i = 1; i < candidateSets.length; i++) {
      resultCveIds = new Set(
        Array.from(resultCveIds).filter(id => candidateSets[i].has(id))
      );
    }
    
    // Get complete vulnerability information based on resulting CVE IDs
    let result: Vulnerability[] = [];
    resultCveIds.forEach(id => {
      const vulns = this.dataMap.get(id);
      if (vulns && vulns.length > 0) {
        result.push(...vulns);
      }
    });
    
    return result;
  }
  
  /**
   * Clear all data and indices
   */
  clear(): void {
    this.dataMap.clear();
    this.severityIndex.clear();
    this.kaiStatusIndex.clear();
    this.vendorIndex.clear();
    this.productIndex.clear();
    this.typeIndex.clear();
    this.cvssIndex.clear();
    this.publishDateIndex.clear();
  }
  
  /**
   * Get list of unique attribute values
   */
  getUniqueValues(field: 'severity' | 'kaiStatus' | 'vendor' | 'product' | 'vulnerabilityType'): string[] {
    switch (field) {
      case 'severity':
        return this.severityIndex.getKeys();
      case 'kaiStatus':
        return this.kaiStatusIndex.getKeys();
      case 'vendor':
        return this.vendorIndex.getKeys();
      case 'product':
        return this.productIndex.getKeys();
      case 'vulnerabilityType':
        return this.typeIndex.getKeys();
      default:
        return [];
    }
  }
} 